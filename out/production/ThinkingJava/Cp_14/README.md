运行时类型信息是的你可以在程序运行时发现和使用类型信息。
本章将讨论Java是如何让我们在运行时识别对象和类的信息。主要有两种方式：一种是“传统的”RTTI,它假定我们已经知道了所有的类型；另一种是反射，它允许我们在运行时发现和使用类的信息。

### 14.1 为什么需要RTTI (Runtime type identification)
默认this返回该对象的hashCode,重写toString 方法之后，this指针返回toString 的方法。

[Code](Code/Shapes.java)

从数组中取出元素的时候，这种容器--实际上它将所有的事物都当做Object持有--会自动的将结果转型回Shape。<font color='red'>这是RTTI的最基本使用形式，因为在Java中，所有的类型都是在运行时候进行正确性检查，这也是RTTI名字的含义:在运行时，识别一个对象的类型</font>
多态是面向对象编程的基本目标。

### 14.2 class 对象
Java使用class对象来执行其RTTI,即使你正在执行的是类似转型这样的操作。class类还拥有大量的使用RTTI的其他方式。
类时程序的一部分，每个类都有一个class对象。换言之每当编写一个并编译一个新类，就会产生一个class对象（更恰当的说，是被保存在一个同名的.class文件中），为了生成这个类的对象，运行这个程序的Java虚拟机，将使用被称为“类加载器的子系统”。
所有的类都是在对其第一次使用时，动态加载到JVM中。当程序创建第一个对类的静态成员的引用是，就会加载这个类，<font color='red'>。这个证明构造器也是类的静态方法，即使构造器之前并没有使用static关键字。</font>
Java 程序在它开始运行之前并非被完全加载，其各个部分是在必需的时候才加载。这一点余许多传统语言都不同，所以Java是一个有着动态加载特性的语言。

类加载的过程：
类加载器首先检查这个类的class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载的时候，他们会接受验证，以确保其没有被破坏，并且不包含不良Java代码（这是Java中用于安全防范的目的措施之一）。

一旦某个类的class对象被加载如内存中，它就用来被创建这个类的所有对象。下面的示范程序可以证明这一点：[Code](Code/)
<font color='red'>上面代码结果和书上的不一样</font>

无论何时，只要你想运行时使用类型信息，就必须首先获得对恰当的class对象的引用。Class.forName()就是实现此功能的便捷途径，因此你不需要为了获得class引用而持有该类型的对选哪个。但是，如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用getClass()方法来获取class引用了，这个方法属于根类Object的一部分，它将返回的表示该对象的实际类型的class引用。class包含了很多有用的方法，下面是其中的一部分[Code](Code/ToyTest.java)

#### 14.2.1 类字面常量
Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量，对上述的程序来说，就像下面这样： FancyToy.class

<font color='red'>注意</font>，当使用.class来创建Class 对象引用时，不会自动的初始化该Class对象。为了使用类而做的准备工作，实际包含三个步骤。
* 加载：这是由类的加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个Class对象，
* 链接：在链接阶段，将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的引用。
* 初始化：如果该类具有超类，则对齐初始化，执行静态初始化器和静态初始化块。

初始化被延迟到了对静态方法(构造器隐式地是静态的)或者非常数，讲台域进行首次引用时才执行[Code](Code/ClassInit.java)

<font color='red'>区别：</font>使用.class 来创建Class 对象的时候不会对类进行初始化，而使用Class.forName()则会对类进行初始化。

#### 14.2.2 泛华class引用
Class 引用总是指向某个class对象，他可以制造类的实例，并包含可能作用于这些实例的所有方法代码。它还包含该类的静态成员，因此，Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。

通过泛型语法，可以让编译器强制执行额外的类型检查[Code](Code/GenericClassReference.java)

在JavaSE5中，Class<?> 优于平凡的Class。

#### 14.2.3 新的转型语法
JavaSE5 还添加了用于Class 引用的转型语法，即cast方法。


### 14.3 类型转换前先做检查
迄今为止，我们已知的RTTI 形式包括：
* 传统的类型转换，如“(Shape)”,由RTTI 确保类型转换的正确性，如果执行一个错误的类型转换，就会抛出一个ClassNotException异常。
* 代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。

RTTI 在Java中还有第三种形式，就是关键字instanceof.它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。

对instanceof 有比较严格的限制：只可将其与命名类型进行比较，而不能与Class对象做比较。如果你的程序中编写了很多instaceof表达式，就说明你的设计可能存在瑕疵。

#### 14.3.1 使用字面常量

#### 14.3.2 动态的instanceof 实例
Class.inInstance 方法提供了一种动态测试对象的途径。

#### 14.3.3
递归计数

### 14.4 注册工厂

### 14.5 instanceof 与Class的等价性

在查询类型的信息时，以instanceof 的形式(即以instanceof 的形式或isInstance()的形式，他们产生相同的结果)与直接比较Class对象有一个很重要的差别。下面的例子展示了这种差别[Code](Code/FmilyVsExactType.java)

instanceof 保持了类型的概念，它指代的事"你是这个类么，或者你是这个类的派生类"，而如果用==比较实际的Class对象，就没有考虑继承---他或者是这个确切的类型，或者不是。


### 14.6 反射： 运行时的类信息
如果不知道某个对象的确切类型，但是假设你获取了一个指向某个会并不在你的程序空间中的对象的引用；事实撒花姑娘，在编译时你的程序根本没法获知这个对象所属的类。在传统的编程环境中不太可能出现这样的情况。但当我们置身于更大的规模的编程世界中，在许多重要情况下就会发生上面的事情。
人们想在云心时获得类的信息的另一个动机，便是希望提供在跨网络的远程平台上创建创建和运行对象能力。这种被称为远程方法调用(RMI),他允许一个Java程序将对象分布到多台机器上。

<font color='red'>反射的支持:</font>Class类与java.lang.reflect 类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类(每个类都实现了Member接口)。

<font color='red'>RTTI和反射之间真正的区别只在于,对于RTTI来说，编译器在编译时打开和检查.class文件。(换句话说，我们可以用普通方式调用对象的所有方法)，而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。</font>

#### 14.6.1 类方法提取器
通常你不需要直接使用反射工具，但是它们在你需要创建更加动态的代码时会很有用、反射在Java中是用来支持其他特性，例如对象序列化和JavaBean ,但是，如果能动态地提取某个会类的信息有时候还是很有用。

Class的getMethods()和getConstuctors()方法分别返回Method 对象的数组和Constructor对象的数组。这两个类都提供了深层方法，用以解析其对象所代表的方法，并获取其名字、输入参数以及返回值。

Class.forName()生成的结果在编译时是不可只的，因此所有的方法特征签名信息斗志在执行时被提取出来。如果研究下JDK文档中关于反射部分，就会看到，反射机制提供了足够的支持，使得能够创建一个在编译时完全未知的对象，并调用此对象的方法。

### 14.7 动态代理
代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。下面展示一个简单的例子
[Code](Code/SimpleProxyDemo.java)

在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易做出修改，从没有使用额外操作转化为使用这些操作，或者反过来，代理就显得很有用。

Java 的动态代理比代理的思想更前进一步，因为它可以动态的创建代理并动态地处理代理对所代理方法的调用。在动态代理上所做的所有调用都会哦被重定向到单一的调用处理器上，他的工作是揭示调用类型并确定相应的对策。下面用动态代理重写上面的代码[Code](Code/)

可以通过传递其他参数，来过滤某些方法的调用。

### 14.8 空对象


### 14.9 接口与类型信息
interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。