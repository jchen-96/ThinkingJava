# 数组
对数组的基本看法是，你可以创建并组装他们，通过整形索引值访问它们的元素，并且他们的尺寸不能被改变。

### 16.1 为什么数组特殊
数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。

* 在泛型之前，其他的容器在处理对象的时，都将它们视为没有任何具体类型。也就是说他们将这些对象都当做Java中所有类的根类Object处理。数组之所以优于<font color='red'>泛型之前</font>的容器，就是因为你可以创建一个数组去持有某种类型。

* 数组可以持有基本类型。

* 随着自动包装机制的出现，容器已经可以与数组几乎在一样方便地用于基本类型中。数组硕果仅存的优点就是效率。

### 16.2 数组是第一级对象
无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个对象，这个对象用以保存其他对象的引用。
length是数组的大小，而不是数组中元素的个数。

### 16.3返回一个数组
假如你要写一个方法，而且希望它返回的不止一个值，二十一组值。这对于c和cpp来说就有点困难，因为他们不能返回一个数组，而只能返回指向数组的指针。这会造成一些问题，因为他使得控制数组的生命周期变得困难，并且很容易造成内存泄露。
在Java中，你可以直接“返回一个数组”，而无需担心要为数组负责---只要你需要他，他就会一直存在，当你使用完之后，垃圾回收器会清理它。

### 16.4创建多维数组
创建多维数组和方便，因为Java中万物皆为对象，多维数组可以理解为数组的数组。

数组中构成矩阵的每个向量卡都可以具有任意长度（这种被称为粗糙数组）
[Code](Code/RaggedArray.java)

### 16.5 数组与泛型
通常，数组与泛型不能很好的结合。你不能实例化具有参数化类型的数组，例如
<font color='red'>Peel<Banana>[] peels=new Peel<Banana>[10]  //不合法</font>
擦除会移除参数类型信息，而数组必须知道它们所持有对象的确切类型，以强制保证类型安全。

但是你可以参数化数组本身的类型。[Code](Code/ParameterizedArrayType.java)

正如上例所示，不能创建泛型数组这一说法并不准确。诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用。

### 16.6 创建测试数据
* Arrays.fill() 只能用同一个值填充各个位置。
* 数据生成器
* 从生成器创建数组

### 16.7 Arrays实用功能
* 复制数组 Java标准库提供有static方法System.arraycopy(),这比用for循环复制快很多。
* 数组的比较 Arrays.equal()方法，长度相同，对应位置上的元素相等（通过对每个对象实用equal方法，所以如果是对象的话，需要重写equal方法）。
* 数组元素的比较 
    * 实现java.lang.Compareable接口
    * 
* 数组排序
    * 使用内置的方法，就可以对任意的基本类型数组排序，也可以对任意的对象数组进行排序，只要该对象实现了Compareable接口或具有相关联的Comparator
* 在已经排序的数组中查找，Arrays.binarySearch()


