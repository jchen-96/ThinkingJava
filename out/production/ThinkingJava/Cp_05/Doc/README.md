随着计算机的发展，“不安全”的编程方式已经逐渐成为编程代价高昂的主要原因之一。
初始化和清理正式涉及安全的两个问题。
cpp 引入构造器的概念，并额外提供了”垃圾回收器“。

### 5.1 用构造器确保初始化
无参构造器          

### 5.2 方法重载
* 区分重载方法
一个独一无二的参数类型列表
<font color=red>注:</font>甚至参数顺序不同也足以区分两个方法

* 涉及基本类型的重载
如果传入的数据类型、小于方法职工的额数据类型会被提升，反之进行窄转化。

* 不能根据返回值重载

### 5.3 默认构造器
* 无构造器会自动创建默认构造器
* 有构造器，不会创建不带参数的构造器

### 5.4 this 关键字
一般不加，只有需要的需要的时候才加[Code](../Code/Leaf.java)
this 关键字对于将当前对象传递给其他对象很有用。

* 在构造器中调用构造器很有用,多个构造器，相互调用时候用this

* static 
static 没有this

### <font color=red>5.5 清理：终结处理和垃圾回收</font>
<font color=red>注:</font>finalize 方法调用了这个函数后，下一次GC才会进行垃圾回收。

而Java对象却并非总是别垃圾回收，换句话说：
1. 对象可能不被垃圾回收
2. 垃圾回收并不等于析构函数
3. 垃圾回收只与内存有关

#### 5.5.1 finalize() 的用途在何
#### 5.5.2 你必须实施清理
#### 5.5.3 终结条件
#### 5.5.4 垃圾回收器如何工作

### 5.6 成员初始化
方法的局部变量补初始化会编译出错，自动初始化的是类的成员变量。

### 5.7 构造器初始化
* 5.7.1 初始化顺序
变量的定义顺序决定了初始化的顺序。
<font color=red> 变量先于任何方法初始化，包括构造器。</font>

* 静态数据的初始化
static 关键字不能用于局部变量
如果一个域是静态的基本类型域，且没有初始化，那么它就会获得基本类型的标准初值。
如果它是一个对象引用，那么它的默认值就是null.

* 显示的静态初始化
静态块

* 非静态实力初始化
非静态块

### 5.8
赋值只是传引用

<font color=red>注:</font>与c系不同，编写程序的时候可以传入变量作为数组的size
创建了一个非基本类型的数组是创建了一个引用数组。

* 5.8.1 可变参数列表
所有的类都直接或者间接的继承自object
object[] args <==> object... args

可以在单一的参数列表中将类型混合在一起。

<font color=red>重载麻烦</font>
* 尽量只在重载方法的一个版本上使用可变参数列表，或者不使用。

### 5.9 枚举类型
Java SE5 中添加的
实用特性:在switch中使用。





