### 7.1 组合语法
将对象引用置于新类，即可


编译器并不会简单的位每一个引用都默认创建对象，如果这样做的话，会额外添加很多负担。如果想初始化这些引用，可以在代码的这些位置进行。
* 在定义对象的地方，这意味着他们总是能够在构造器被调用之前被初始化。
* 在类的构造器中
* 就在正要使用这些对象之前，这种方式成为惰性初始化，在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。
* 使用实例初始化 
[Code](../Code/Bath.java)

### 继承语法
extends 会得到基类中多有的域和方法

#### 7.2.1 初始化基类
* 当创建一个导出类对象是，该对象包含一个基类的子对象
* 带参数的构造器，第一行super 显式调用
[Code](../Code/Cartoon.java)

### 7.3 代理
通过一个类作为代理，隐式的调用另一个类。

### 7.4 组合和继承的结合使用
#### 7.4.1 确保正确的清理
#### 7.4.2 名称屏蔽
如果Java 的基类拥有某个已经多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽在基类中的任何版本，可以通过super调用。

### 7.5 组合与继承之间的选择

### 7.6 protected 关键字=default+导出类可以访问

### 7.7 向上转型

### 7.8 final 关键字
* 一个永不改变的编译时的常量
* 一个在运行时被初始化的值，而你不希望它被改变。

#### final 数据
final 修饰引用类型，作用类似常量指针
static 强调只有一份，final 常量

空白final ,必须在构造器中进行初始化！！！

#### final 方法

把方法锁定，以防止任何继承类修改它的含义。
将一个方法指明为final ，将所有的对该方法的调用转为内嵌调用(早期java版本，现在不)


#### final 和private 关键字
类似所有的private 方法都隐式地指定为是final的，由于无法取用private 方法，所以也就无法覆盖它。可以对private 方法添加final 修饰，但这并不能给该方法添加任何额外的意义。


#### final 类
不允许继承

### 7.9 初始化及类的加载
类的代码在初次使用时才加载，这通常是指加载发生于创建类的第一个对象之时，但是当访问static 域或static 方法时，也会发生加载。